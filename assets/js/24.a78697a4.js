(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{263:function(_,v,t){_.exports=t.p+"assets/img/9ef305da-212e-445b-8ef6-6ab9c31358e5.47a820dd.jpg"},264:function(_,v,t){_.exports=t.p+"assets/img/c81ebefe-818f-4791-9c01-8ceebf424a71.068b5232.jpg"},532:function(_,v,t){"use strict";t.r(v);var r=t(2),e=Object(r.a)({},function(){var _=this,v=_.$createElement,r=_._self._c||v;return r("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[r("h1",{attrs:{id:"传输层协议"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#传输层协议","aria-hidden":"true"}},[_._v("#")]),_._v(" 传输层协议")]),_._v(" "),r("p",[_._v("网络协议族中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。")]),_._v(" "),r("h2",{attrs:{id:"tcp"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tcp","aria-hidden":"true"}},[_._v("#")]),_._v(" TCP")]),_._v(" "),r("p",[r("strong",[_._v("传输控制协议")]),_._v("（Transmission Control Protocol，TCP）是一种面向连接（连接导向）的、可靠的、 基于 IP 协议的传输层协议。")]),_._v(" "),r("h3",{attrs:{id:"标志比特位"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#标志比特位","aria-hidden":"true"}},[_._v("#")]),_._v(" 标志比特位")]),_._v(" "),r("p",[_._v("TCP 首部标志比特有 6 个：URG、ACK、PSH、RST、SYN、FIN")]),_._v(" "),r("ul",[r("li",[r("strong",[_._v("URG")]),_._v("：紧急指针")]),_._v(" "),r("li",[r("strong",[_._v("ACK")]),_._v("：确认序号有效")]),_._v(" "),r("li",[r("strong",[_._v("PSH")]),_._v("：尽可能快地将数据送往接收进程")]),_._v(" "),r("li",[r("strong",[_._v("RST")]),_._v("：重建连接")]),_._v(" "),r("li",[r("strong",[_._v("SYN")]),_._v("：同步序号来发起一个连接")]),_._v(" "),r("li",[r("strong",[_._v("FIN")]),_._v("：发送方完成发送任务")])]),_._v(" "),r("h3",{attrs:{id:"三次握手"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三次握手","aria-hidden":"true"}},[_._v("#")]),_._v(" 三次握手")]),_._v(" "),r("p",[_._v("TCP 提供"),r("span",{staticStyle:{"font-weight":"bold",color:"red"}},[_._v("面向有连接")]),_._v("的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。")]),_._v(" "),r("p",[_._v("三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在 Socket 编程中，这一过程由客户端执行 connect 来触发。")]),_._v(" "),r("p",[r("strong",[_._v("三次握手流程图")])]),_._v(" "),r("p",[r("img",{attrs:{src:t(263),alt:"三次握手流程图"}})]),_._v(" "),r("ol",[r("li",[r("strong",[_._v("第一次握手")]),_._v("：客户端将标志位 SYN 置为 1，随机产生一个值 "),r("code",[_._v("seq = X")]),_._v("（由操作系统动态随机选取一个 32 位长的序列号，通常为 0），并将该数据包发送给服务器端，客户端进入 "),r("code",[_._v("SYN_SENT")]),_._v(" 状态，等待服务器确认")]),_._v(" "),r("li",[r("strong",[_._v("第二次握手")]),_._v("：服务端收到数据包后由标志位 "),r("code",[_._v("SYN = 1")]),_._v(" 知道客户端"),r("strong",[_._v("希望请求建立连接")]),_._v("，服务端将标志位 SYN 和 ACK 都置为 1，"),r("code",[_._v("ack = X+1")]),_._v("（第一次握手中的 seq 值递加 1），"),r("code",[_._v("seq=Y")]),_._v("（由操作系统动态随机选取一个 32 位长的序列号，这里通常为 0），设置以下首部标志后将该数据包发送给客户端"),r("strong",[_._v("以确认建立连接请求")]),_._v("，服务端进入 "),r("code",[_._v("SYN_RCVD")]),_._v(" 状态。")]),_._v(" "),r("li",[r("strong",[_._v("第三次握手")]),_._v("：客户端收到确认后，检查 "),r("code",[_._v("ack")]),_._v(" 是否为 "),r("code",[_._v("1")]),_._v("，如果正确则将标志位 "),r("code",[_._v("ACK")]),_._v(" 置为 1，"),r("code",[_._v("ack=Y+1")]),_._v("（第二次握手的 seq 值递加 1），"),r("code",[_._v("seq=X+1")]),_._v("（第二次握手中的 ack 值），并将数据包发送给服务器端，服务器端检查 "),r("code",[_._v("ack")]),_._v(" 是否为 "),r("code",[_._v("K+1")]),_._v("，"),r("code",[_._v("ACK")]),_._v(" 是否为 1，如果正确则连接建立成功，客户端和服务器端进入 ESTABLISHED 状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。")])]),_._v(" "),r("p",[_._v("握手过程中传送的包里"),r("span",{staticStyle:{"font-weight":"bold",color:"red"}},[_._v("不包含数据")]),_._v("，只有三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。")]),_._v(" "),r("p",[r("strong",[_._v("为什么建立 TCP 连接需要三次握手？")])]),_._v(" "),r("p",[_._v("如果只进行一次握手，无法确认双方的情况，因此建立连接必然两次起步。")]),_._v(" "),r("p",[r("strong",[_._v("三次握手中的第一次握手可以携带数据吗？")])]),_._v(" "),r("p",[_._v("不可以，因为三次握手还没完成。")]),_._v(" "),r("p",[r("strong",[_._v("第三次握手可以发送数据吗？为何？")])]),_._v(" "),r("p",[_._v("可以。因为能够发出第三次握手报文的主机，肯定接收到第二次（来自服务端）的握手报文。因为伪造 IP 的主机不会收到第二次报文。")]),_._v(" "),r("p",[r("strong",[_._v("对方难道不可以将数据缓存下来，等握手成功后再提交给应用程序？")])]),_._v(" "),r("p",[_._v("这样会放大 SYN FLOOD 攻击。如果攻击者伪造了成千上万的握手报文，携带了 1K+ 字节的数据，而接收方会开辟大量的缓存来容纳这些巨大数据，内存会很容易耗尽，从而拒绝服务。")]),_._v(" "),r("h3",{attrs:{id:"四次挥手"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手","aria-hidden":"true"}},[_._v("#")]),_._v(" 四次挥手")]),_._v(" "),r("p",[_._v("四次挥手即终止 TCP 连接，就是指断开一个 TCP 连接时，需要客户端和服务端总共发送 4 个包以确认连接的断开。在 Socket 编程中，这一过程由客户端或服务端任一方执行 close 来触发。")]),_._v(" "),r("p",[_._v("由于 TCP 连接是"),r("span",{staticStyle:{"font-weight":"bold",color:"red"}},[_._v("全双工")]),_._v("的，因此，每个方向都必须要"),r("strong",[_._v("单独进行关闭")]),_._v("，这一原则是当一方完成数据发送任务后，发送一个 FIN（Finish） 来终止这一方向的连接，收到一个 FIN 只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个 TCP 连接上仍然能够发送数据，直到这一方向也发送了 FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。")]),_._v(" "),r("p",[r("strong",[_._v("四次挥手流程图")])]),_._v(" "),r("p",[r("img",{attrs:{src:t(264),alt:"四次挥手流程图"}})]),_._v(" "),r("ol",[r("li",[r("strong",[_._v("第一次挥手")]),_._v("：客户端发送一个 FIN=1 数据包，用于关闭客户端到服务器端的数据传送，客户端进入 "),r("code",[_._v("FIN_WAIT_1")]),_._v(' 状态。意思是说"我客户端没有数据要发给你了"，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。')]),_._v(" "),r("li",[r("strong",[_._v("第二次挥手")]),_._v("：服务器端收到 FIN 后，先发送 "),r("code",[_._v("ack = u+1")]),_._v("，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入 "),r("code",[_._v("FIN_WAIT_2")]),_._v(" 状态，继续等待服务器端的 FIN 报文。")]),_._v(" "),r("li",[r("strong",[_._v("第三次挥手")]),_._v("：当服务器端确定数据已发送完成，则向客户端发送 "),r("code",[_._v("FIN = N")]),_._v(" 报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入 "),r("code",[_._v("LAST_ACK")]),_._v(" 状态。")]),_._v(" "),r("li",[r("strong",[_._v("第四次挥手")]),_._v("：客户端收到 "),r("code",[_._v("FIN = N")]),_._v(" 报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送 "),r("code",[_._v("ack = w+1")]),_._v(" 后进入 "),r("code",[_._v("TIME_WAIT")]),_._v(" 状态，如果服务端端没有收到 ACK 则可以重传。服务器端收到 ACK 后，就知道可以断开连接了。客户端等待了 2MSL 后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。")])]),_._v(" "),r("ul",[r("li",[_._v("第一次挥手是"),r("strong",[_._v("服务端确认客户端需要断开连接")])]),_._v(" "),r("li",[_._v("第二次挥手是"),r("strong",[_._v("客户端确认服务器接收断开请求")])]),_._v(" "),r("li",[_._v("第三次挥手是"),r("strong",[_._v("客户端确认服务器数据发完，断开连接")])]),_._v(" "),r("li",[_._v("第四次挥手是"),r("strong",[_._v("服务端确认客户端断开连接，断开连接")])])]),_._v(" "),r("p",[_._v("所以如果服务端的数据全部发送完，是没有第三次挥手，直接进入第四次挥手。")]),_._v(" "),r("p",[r("strong",[_._v("为什么断开 TCP 连接需要四次挥手？")])]),_._v(" "),r("p",[_._v("全双工的通信方式，发送方和接收方都需要一个 FIN 和 ACK 报文。相较于 TCP 的建立，TCP 的关闭时需要释放两端的资源（发送未完成的数据），因此多一个对端的 FIN 的状态")]),_._v(" "),r("p",[r("strong",[_._v("为什么基于 TCP 的程序往往都有个应用层的心跳检测机制？")])]),_._v(" "),r("p",[_._v("TCP 建立链接后，只是在两端的内核里面维持 TCP 信息，实际上并没有一个物理的连接通路，对端这个时候挂了，谁也不知道。")]),_._v(" "),r("h3",{attrs:{id:"syn-flood-攻击"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#syn-flood-攻击","aria-hidden":"true"}},[_._v("#")]),_._v(" SYN FLOOD 攻击")]),_._v(" "),r("p",[_._v("攻击原理：")]),_._v(" "),r("ul",[r("li",[_._v("利用 TCP 协议缺陷发送大量伪造的 TCP 连接请求，从而使得被攻击方资源耗尽（CPU 满负荷或内存不足）的攻击方式。")]),_._v(" "),r("li",[_._v("第二次握手时候会出现：SYN Timeout，一个用户向服务器发送了 SYN 报文后突然死机或掉线，服务器等待 SYN，ACK。")])]),_._v(" "),r("h2",{attrs:{id:"udp"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#udp","aria-hidden":"true"}},[_._v("#")]),_._v(" UDP")]),_._v(" "),r("p",[_._v("用户数据报协议（英语：User Datagram Protocol，UDP），又称使用者资料包协定，是一个简单的面向数据报的传输层协议，正式规范为 RFC 768。在 TCP/IP 模型中，UDP 为网络层以上和应用层以下提供了一个简单的接口。UDP 只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以 UDP 有时候也被认为是不可靠的数据报协议）。UDP 在 IP 数据报的头部仅仅加入了复用和数据校验（字段）。")]),_._v(" "),r("p",[r("strong",[_._v("优点")])]),_._v(" "),r("ul",[r("li",[_._v("无需建立连接（减少延迟）")]),_._v(" "),r("li",[_._v("实现简单：无需维护连接状态")]),_._v(" "),r("li",[_._v("头部开销小（最小值为 8byte）")]),_._v(" "),r("li",[_._v("没有拥塞控制：应用可以更好的控制发送时间和发送速率")])]),_._v(" "),r("p",[r("strong",[_._v("基于 UDP 协议的有：")])]),_._v(" "),r("ul",[r("li",[_._v("域名系统（DNS）")]),_._v(" "),r("li",[_._v("简单网络管理协议（SNMP）")]),_._v(" "),r("li",[_._v("动态主机配置协议（DHCP）")]),_._v(" "),r("li",[_._v("路由信息协议（RIP）")]),_._v(" "),r("li",[_._v("自举协议（BOOTP）")]),_._v(" "),r("li",[_._v("简单文件传输协议（TFTP）")])]),_._v(" "),r("hr"),_._v(" "),r("p",[r("strong",[_._v("参考资料：")])]),_._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://juejin.im/post/5a069b6d51882509e5432656",target:"_blank",rel:"noopener noreferrer"}},[_._v("📝 一篇文章带你熟悉 TCP/IP 协议"),r("OutboundLink")],1)]),_._v(" "),r("li",[r("a",{attrs:{href:"https://juejin.im/post/5ba3b68c6fb9a05d287345ab",target:"_blank",rel:"noopener noreferrer"}},[_._v("📝 前端必须懂的计算机网络知识"),r("OutboundLink")],1)])])])},[],!1,null,null,null);v.default=e.exports}}]);